
#===============================================================================#
# ASCII Text to DNA Translator							#
# Michael Ting									#
# 2 August 2013									#
#===============================================================================#

Package to encode ASCII text into DNA as an information storage medium.

Two options are available:
 - 4-Base Codon Translation
	256-character ASCII is used to translate to 4-base DNA codons, 
	analogous to the quaternary numeral system where T:0, A:1, G:2, C:3.
 - Binary Intermediate Translation
	256-character ASCII numeric encodings is converted to 8-bit wide
	binary, from which the binary code is converted one-to-one to
	DNA bases, where 0: (A or C), 1: (G or T). Bases are selected
	at random using probability distributions with equal weight
	for each base, and repetitive binary numerals result in forced 
	alternating bases to reduce homopolymers and balance GC content.

#=======#
# Notes #
#=======#

DNA output from binaryDNA will be twice as long as the output from ASCIIcodons.

ASCIIcodons encodes 256 characters using 4-base codons (4^4 distinct codons).
Therefore, one character corresponds to 4 DNA bases.

binaryDNA encodes one-to-one between binary and DNA bases, with 0 mapping to
A or C and 1 mapping to G or T. Binary representations of ASCII codes are
a byte (or 8 bits) long, so one character corresponds to 8 DNA bases.

#=============#
# Future Work #
#=============#

===Codons===

A known issue is that standard English alphabet characters are encoded within
the range of values 64-128, meaning using base 4 encoding creates a skewed
distribution of DNA codons when sampling the alphabet. All alphabetical
characters will begin with the same base in the initial base position, which
can result in high GC content for long strings of English text, given that
the first base is C or G.

There is a quick, but temporary, fix for this - mapping T:0,A:1,G:2,C:3 - but
these mappings are arbitrary and still skew the distribution towards AT.

A better solution would be to randomize the mapping of codons to ASCII characters
and/or reduce the number of bases used in the codons by eliminating unused
ASCII characters.

- Change the distribution of character mappings to be more uniform
- Handle DNA strings of length indivisible by 4
- Allow reverse translation in 4 different reading frames

#====================#
# Encoding Quick Use #
#====================#

Codons:

Modify the "infile" variable in run_encode_codon.py to the name of the ASCII
text file you want to convert into DNA. You may also choose to modify the 
outfile and check file names. Then run the command:
	
    $ python run_encode_codon.py

Binary:

Modify the "infile" variable in run_encode_binary.py to the name of the ASCII
text file you want to convert into DNA. You may also choose to modify the
outfile and check file names. Then run the command:

    $ python run_encode_binary.py

Both programs will produce output files (outfile) and check files (check).

#===================#
# Using ASCIIcodons #
#===================#

Current object classes included:

* TextToDNA
* DNAToText

To translate input files, start up the Python interpreter and instantiate
one of the above object classes:

>>> from ASCIIcodons import TextToDNA
>>> obj = TextToDNA()

To translate an ASCII text file to DNA, specify input and output files:

>>> obj.translate("/path/to/ASCIItextfile","/path/to/outputfile")

The output file will print to the screen, and can also be accessed from the
specific path location.

For reverse translation from DNA to ASCII text:

>>> from ASCIIcodons import DNAToText
>>> obj = DNAToText()
>>> obj.translate("/path/to/dnatextfile","/path/to/outputfile")

To use all object classes simultaneously:

>>> from ASCIIcodons import *

#=================#
# Using binaryDNA #
#=================#

Current object classes include:

* BinaryTextToDNA
* DNAToBinaryText

To translate input files, start up the Python interpreter and instantiate
one of the above object classes:

>>> from binaryDNA import BinaryTextToDNA
>>> obj = BinaryTextToDNA()

To Translate an ASCII text file to DNA through binary, specify input and output files:

>>> obj.translate("/path/to/ASCIItextfile","/path/to/outputfile")

The output file will print to the screen, and can also be accessed from the
specific path location.

For reverse translation from DNA to ASCII text through binary:

>>> from binaryDNA import DNAToBinaryText
>>> obj = DNAToBinaryText()
>>> obj.translate("/path/to/dnatextfile","/path/to/outputfile")

To use all object classes simultaneously:

>>> from binaryDNA import *

#=====================#
# Formatting of files #
#=====================#

Input text files support the ASCII 256-character set.

Input DNA files should be formatted as plain strings of upper-case DNA:

	ATGAGGATTTACGGGT
	CCAC
	ATCGAGACCCCA

For 4-base codons, length of DNA strings should be a multiple of 4. Handling of DNA 
with lengths indivisible by 4 will be implemented in the future.

For binary encoding, length of DNA strings should be a multiple of 8, as the binary
enconding of DNA utilizes 8 bits for each character in 256-ASCII.

#===================#
# Chunker Quick Use #
#===================#

Codons:

Modify the "infsta" variable in run_chunker_codon.py to the name of the FASTA
file you want to convert into DNA. You may also choose to modify the 
cfname, mfname, and trname variables. Then run the command:
	
    $ python run_chunker_codon.py

Binary:

Modify the "infsta" variable in run_chunker_binary.py to the name of the FASTA
file you want to convert into DNA. You may also choose to modify the
cfname, mfname, and trname variables. Then run the command:

    $ python run_chunker_binary.py

Both programs will produce a 150bp long chunk file (cfname), a chunk file with
front adaptors removed (mfname), and a translation file as a check for correct
encoding (trname).

#=====================#
# Codon Array Chunker #
#=====================#

- Run with contig and step size as 76
- TAG at head of dna is format $ _ _ # _ _ _
  meaning 7 characters, so 28 DNA bases
- To ensure mod 4, pad the ends of the DNA with 2 bases (106 --> 104, padded with AA at the end)
- 104-28 = 76 for the chunk size
- stuffer sequence is TGAC, corresponding to single quote '

Steps to replicate:
$ python arraychunker.py infile.fasta outfile.txt 76 76 TGAC
$ python
>>> import os
>>> infile = open("outfile.txt","r")
>>> newfile = open("new.txt","w")
>>> for line in infile:
...     newfile.write("%s\n" % line[2:])    # to account for correct reading frame since adaptor is 22 bp
...	newfile.flush()
...	os.fsync(newfile.fileno())
>>>	infile.close()
>>>	newfile.close()
$ ls
$ python
>>> from ASCIIcodons import *
>>> o = DNAToText()
>>> o.translate("new.txt","trans.txt")

#======================#
# Binary Array Chunker #
#======================#

- Run with contig and step size as 48
- TAG at head of dna is format $ _ _ # _ _ _
  meaning 7 characters, so 56 DNA bases
- To ensure mod 8, pad the ends of the DNA with 2 bases (106 --> 104, padded with AA at the end)
- 104-56 = 48 for the chunk size
- stuffer sequence is TGAC, corresponding to single quote '

Steps to replicate:
$ python binarraychunker.py infile.txt outfile.txt 48 48 ACGACTGT
$ python
>>> import os
>>> infile = open("outfile.txt","r")
>>> newfile = open("new.txt","w")
>>> for line in infile:
...     newfile.write("%s\n" % line[22:126])    # to account for correct reading frame since adaptor is 22 bp
...		newfile.flush() 						# for huge files, may stop writing, so we need to flush I/O
...		os.fsync(newfile.fileno())
>>> infile.close()
>>> newfile.close()
$ ls
$ python
>>> from binaryDNA import *
>>> o = DNAToBinaryText()
>>> o.translate("new.txt","trans.txt")

